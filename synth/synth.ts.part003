                                let pitchIter: number = lastPitch;
                                if (pitchIter < pitch) {
                                    while (pitchIter != pitch) {
                                        pitchIter++;
                                        if (recentPitches.indexOf(pitchIter) == -1) interval++;
                                    }
                                } else {
                                    while (pitchIter != pitch) {
                                        pitchIter--;
                                        if (recentPitches.indexOf(pitchIter) == -1) interval--;
                                    }
                                }
                                bits.write(1, 0);
                                bits.writePitchInterval(interval);
                            } else {
                                bits.write(1, 1);
                                bits.write(4, pitchIndex);
                                recentPitches.splice(pitchIndex, 1);
                            }
                            recentPitches.unshift(pitch);
                            if (recentPitches.length > 16) recentPitches.pop();

                            if (i == note.pitches.length - 1) {
                                lastPitch = note.pitches[0];
                            } else {
                                lastPitch = pitch;
                            }
                        }

                        if (note.start == 0) {
                            bits.write(1, note.continuesLastPattern ? 1 : 0);
                        }

                        curPart = note.end;
                    }

                    if (curPart < this.beatsPerBar * Config.partsPerBeat + (+isModChannel)) {
                        bits.write(2, 0); // rest
                        if (isModChannel) bits.write(1, 0); // positive offset
                        bits.writePartDuration(this.beatsPerBar * Config.partsPerBeat + (+isModChannel) - curPart);
                    }
                } else {
                    bits.write(1, 0);
                }
            }
        }
        let stringLength: number = bits.lengthBase64();
        let digits: number[] = [];
        while (stringLength > 0) {
            digits.unshift(base64IntToCharCode[stringLength & 0x3f]);
            stringLength = stringLength >> 6;
        }
        buffer.push(base64IntToCharCode[digits.length]);
        Array.prototype.push.apply(buffer, digits); // append digits to buffer.
        bits.encodeBase64(buffer);

        const maxApplyArgs: number = 64000;
        let customSamplesStr = "";
        if (EditorConfig.customSamples != undefined && EditorConfig.customSamples.length > 0) {
            customSamplesStr = "|" + EditorConfig.customSamples.join("|")

        }
        //samplemark
        if (buffer.length < maxApplyArgs) {
            // Note: Function.apply may break for long argument lists. 
            return String.fromCharCode.apply(null, buffer) + customSamplesStr;
            //samplemark
        } else {
            let result: string = "";
            for (let i: number = 0; i < buffer.length; i += maxApplyArgs) {
                result += String.fromCharCode.apply(null, buffer.slice(i, i + maxApplyArgs));
            }
            return result + customSamplesStr;
            //samplemark
        }
    }

    private static _envelopeFromLegacyIndex(legacyIndex: number): Envelope {
        // I swapped the order of "custom"/"steady", now "none"/"note size".
        if (legacyIndex == 0) legacyIndex = 1; else if (legacyIndex == 1) legacyIndex = 0;
        return Config.envelopes[clamp(0, Config.envelopes.length, legacyIndex)];
    }

    public fromBase64String(compressed: string, jsonFormat: string = "auto"): void {
        if (compressed == null || compressed == "") {
            Song._clearSamples();

            this.initToDefault(true);
            return;
        }
        this.channels.length = 0;
        
        let charIndex: number = 0;
        // skip whitespace.
        while (compressed.charCodeAt(charIndex) <= CharCode.SPACE) charIndex++;
        // skip hash mark.
        if (compressed.startsWith("##")) {
			URLDebugger.start(compressed);
			// Remove one hash so the rest of the logic doesn't get confused.
			compressed = compressed.substring(1);
		}
        if (compressed.charCodeAt(charIndex) == CharCode.HASH) charIndex++;
        // if it starts with curly brace, treat it as JSON.
        if (compressed.charCodeAt(charIndex) == CharCode.LEFT_CURLY_BRACE) {
            this.fromJsonObject(JSON.parse(charIndex == 0 ? compressed : compressed.substring(charIndex)), jsonFormat);
            return;
        }

        const variantTest: number = compressed.charCodeAt(charIndex);
        //I cleaned up these boolean setters with an initial value. Idk why this wasn't done earlier...
        let fromBeepBox: boolean = false;
        let fromJummBox: boolean = false;
        let fromGoldBox: boolean = false;
        let fromUltraBox: boolean = false;
        let fromSlarmoosBox: boolean = false;
        let fromSomethingBox: boolean = false;
        // let fromMidbox: boolean;
        // let fromDogebox2: boolean;
        // let fromAbyssBox: boolean;

        // Detect variant here. If version doesn't match known variant, assume it is a vanilla string which does not report variant.
        if (variantTest == 0x6A) { //"j"
            fromJummBox = true;
            charIndex++;
        } else if (variantTest == 0x67) { //"g"
            fromGoldBox = true;
            charIndex++;
        } else if (variantTest == 0x75) { //"u"
            fromUltraBox = true;
            charIndex++;
        } else if (variantTest == 0x64) { //"d" 
            fromJummBox = true;
            // to-do: add explicit dogebox2 support
            //fromDogeBox2 = true;
            charIndex++;
        } else if (variantTest == 0x61) { //"a" Abyssbox does urls the same as ultrabox //not quite anymore, but oh well
            fromUltraBox = true;
            charIndex++;
        } else if (variantTest == 0x73) { //"s"
            fromSlarmoosBox = true
            charIndex++;
        } else if (variantTest == 0x62) { // "b"
            fromSomethingBox = true;
            charIndex++;
        } else {
            fromBeepBox = true;
        }

        const version: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
        if (fromBeepBox && (version == -1 || version > Song._latestBeepboxVersion || version < Song._oldestBeepboxVersion)) return;
        if (fromJummBox && (version == -1 || version > Song._latestJummBoxVersion || version < Song._oldestJummBoxVersion)) return;
        if (fromGoldBox && (version == -1 || version > Song._latestGoldBoxVersion || version < Song._oldestGoldBoxVersion)) return;
        if (fromUltraBox && (version == -1 || version > Song._latestUltraBoxVersion || version < Song._oldestUltraBoxVersion)) return;
        if (fromSlarmoosBox && (version == -1 || version > Song._latestSlarmoosBoxVersion || version < Song._oldestSlarmoosBoxVersion)) return;
        if (fromSomethingBox && (version == -1 || version > Song._latestSomethingBoxVersion || version < Song._oldestSomethingBoxVersion)) return;
        const beforeTwo: boolean = version < 2;
        const beforeThree: boolean = version < 3;
        const beforeFour: boolean = version < 4;
        const beforeFive: boolean = version < 5;
        const beforeSix: boolean = version < 6;
        const beforeSeven: boolean = version < 7;
        const beforeEight: boolean = version < 8;
        const beforeNine: boolean = version < 9;
        this.initToDefault((fromBeepBox && beforeNine) || ((fromJummBox && beforeFive) || (beforeFour && fromGoldBox)));
        const forceSimpleFilter: boolean = (fromBeepBox && beforeNine || fromJummBox && beforeFive);

        let willLoadLegacySamplesForOldSongs: boolean = false;

        if (fromSlarmoosBox || fromUltraBox || fromGoldBox || fromSomethingBox) {
            compressed = compressed.replaceAll("%7C", "|")
            var compressed_array = compressed.split("|");
            compressed = compressed_array.shift()!;
            if (EditorConfig.customSamples == null || EditorConfig.customSamples.join(", ") != compressed_array.join(", ")) {

                Song._restoreChipWaveListToDefault();

                let willLoadLegacySamples = false;
                let willLoadNintariboxSamples = false;
                let willLoadMarioPaintboxSamples = false;
                const customSampleUrls: string[] = [];
                const customSamplePresets: Preset[] = [];
                sampleLoadingState.statusTable = {};
                sampleLoadingState.urlTable = {};
                sampleLoadingState.totalSamples = 0;
                sampleLoadingState.samplesLoaded = 0;
                sampleLoadEvents.dispatchEvent(new SampleLoadedEvent(
                    sampleLoadingState.totalSamples,
                    sampleLoadingState.samplesLoaded
                ));
                for (const url of compressed_array) {
                    if (url.toLowerCase() === "legacysamples") {
                        if (!willLoadLegacySamples) {
                            willLoadLegacySamples = true;
                            customSampleUrls.push(url);
                            loadBuiltInSamples(0);
                        }
                    }
                    else if (url.toLowerCase() === "nintariboxsamples") {
                        if (!willLoadNintariboxSamples) {
                            willLoadNintariboxSamples = true;
                            customSampleUrls.push(url);
                            loadBuiltInSamples(1);
                        }
                    }
                    else if (url.toLowerCase() === "mariopaintboxsamples") {
                        if (!willLoadMarioPaintboxSamples) {
                            willLoadMarioPaintboxSamples = true;
                            customSampleUrls.push(url);
                            loadBuiltInSamples(2);
                        }
                    }

                    else {
                        // UB version 2 URLs and below will be using the old syntax, so we do need to parse it in that case.
                        // UB version 3 URLs should only have the new syntax, though, unless the user has edited the URL manually.
                        const parseOldSyntax: boolean = beforeThree;
                        const ok: boolean = Song._parseAndConfigureCustomSample(url, customSampleUrls, customSamplePresets, sampleLoadingState, parseOldSyntax);
                        if (!ok) {
                            continue;
                        }
                    }
                }
                if (customSampleUrls.length > 0) {
                    EditorConfig.customSamples = customSampleUrls;
                }
                if (customSamplePresets.length > 0) {
                    const customSamplePresetsMap: DictionaryArray<Preset> = toNameMap(customSamplePresets);
                    EditorConfig.presetCategories[EditorConfig.presetCategories.length] = {
                        name: "Custom Sample Presets",
                        presets: customSamplePresetsMap,
                        index: EditorConfig.presetCategories.length,
                    };
                    // EditorConfig.presetCategories.splice(1, 0, {
                    // name: "Custom Sample Presets",
                    // presets: customSamplePresets,
                    // index: EditorConfig.presetCategories.length,
                    // });
                }


            }
            //samplemark
        }

        if (beforeThree && fromBeepBox) {
            // Originally, the only instrument transition was "instant" and the only drum wave was "retro".
            for (const channel of this.channels) {
                channel.instruments[0].transition = Config.transitions.dictionary["interrupt"].index;
                channel.instruments[0].effects |= 1 << EffectType.transition;
            }
            this.channels[3].instruments[0].chipNoise = 0;
        }

        let legacySettingsCache: LegacySettings[][] | null = null;
        if ((fromBeepBox && beforeNine) || ((fromJummBox && beforeFive) || (beforeFour && fromGoldBox))) {
            // Unfortunately, old versions of BeepBox had a variety of different ways of saving
            // filter-and-envelope-related parameters in the URL, and none of them directly
            // correspond to the new way of saving these parameters. We can approximate the old
            // settings by collecting all the old settings for an instrument and passing them to
            // convertLegacySettings(), so I use this data structure to collect the settings
            // for each instrument if necessary.
            legacySettingsCache = [];
            for (let i: number = legacySettingsCache.length; i < this.getChannelCount(); i++) {
                legacySettingsCache[i] = [];
                for (let j: number = 0; j < Config.instrumentCountMin; j++) legacySettingsCache[i][j] = {};
            }
        }

        let legacyGlobalReverb: number = 0; // beforeNine reverb was song-global, record that reverb here and adapt it to instruments as needed.

        let instrumentChannelIterator: number = 0;
        let instrumentIndexIterator: number = -1;
        let command: number;
        let useSlowerArpSpeed: boolean = false;
        let useFastTwoNoteArp: boolean = false;
		try {
			while (charIndex < compressed.length) switch (command = compressed.charCodeAt(charIndex++)) {
            case SongTagCode.songTitle: {
                // Length of song name string
                var songNameLength = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                this.title = decodeURIComponent(compressed.substring(charIndex, charIndex + songNameLength));
                document.title = this.title + " - " + EditorConfig.versionDisplayName;

                charIndex += songNameLength;
            } break;
            case SongTagCode.channelCount: {
                const startIndex = charIndex;
                if (fromSomethingBox) {
                    // SomethingBox format: read total count, then each channel's type.
                    const totalChannels =
                        base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                    this.channels.length = 0;
                    for (let i = 0; i < totalChannels; i++) {
                        const channelType = base64CharCodeToInt[
                            compressed.charCodeAt(charIndex++)
                        ] as ChannelType;
                        this.channels.push(new Channel(channelType));
                    }
                } else {
                    // Legacy format for all other mods: read fixed counts.
                    const pitchCount = validateRange(
                        Config.pitchChannelCountMin,
                        Config.pitchChannelCountMax,
                        base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                    );
                    const noiseCount = validateRange(
                        Config.noiseChannelCountMin,
                        Config.noiseChannelCountMax,
                        base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                    );
                    let modCount = 0;
                    if (!fromBeepBox && !(fromJummBox && beforeTwo)) {
                        modCount = validateRange(
                            Config.modChannelCountMin,
                            Config.modChannelCountMax,
                            base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                        );
                    }
            
                    this.channels.length = 0;
                    for (let i = 0; i < pitchCount; i++)
                        this.channels.push(new Channel(ChannelType.Pitch));
                    for (let i = 0; i < noiseCount; i++)
                        this.channels.push(new Channel(ChannelType.Noise));
                    for (let i = 0; i < modCount; i++)
                        this.channels.push(new Channel(ChannelType.Mod));
                    // This legacy cache setup is ONLY needed for old formats.
                    if ((fromBeepBox && beforeNine) || ((fromJummBox && beforeFive) || (beforeFour && fromGoldBox))) {
                        for (let i: number = legacySettingsCache!.length; i < this.getChannelCount(); i++) {
                            legacySettingsCache![i] = [];
                            for (let j: number = 0; j < Config.instrumentCountMin; j++) legacySettingsCache![i][j] = {};
                        }
                    }
                }
                URLDebugger.log("n", "channel count", startIndex, charIndex, { pitch: this.pitchChannelCount, noise: this.noiseChannelCount, mod: this.modChannelCount });
            } break;
            case SongTagCode.scale: {
                const startIndex = charIndex;
                this.scale = clamp(0, Config.scales.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                // All the scales were jumbled around by Jummbox. Just convert to free.
                if (this.scale == Config.scales["dictionary"]["Custom"].index) {
                    for (var i = 1; i < Config.pitchesPerOctave; i++) {
                        this.scaleCustom[i] = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] == 1; // ineffiecent? yes, all we're going to do for now? hell yes
                    }
                }
                if (fromBeepBox) this.scale = 0;
                URLDebugger.log("s", "scale", startIndex, charIndex, { scale: this.scale, custom: this.scaleCustom });
            } break;
            case SongTagCode.key: {
                const startIndex = charIndex;
                if (beforeSeven && fromBeepBox) {
                    this.key = clamp(0, Config.keys.length, 11 - base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                    this.octave = 0;
                } else if (fromBeepBox || fromJummBox) {
                    this.key = clamp(0, Config.keys.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                    this.octave = 0;
                } else if (fromGoldBox || (beforeThree && fromUltraBox)) {
                    // GoldBox (so far) didn't introduce any new keys, but old
                    // songs made with early versions of UltraBox share the
                    // same URL format, and those can have more keys. This
                    // shouldn't really result in anything other than 0-11 for
                    // the key and 0 for the octave for GoldBox songs.
                    const rawKeyIndex: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                    const [key, octave]: [number, number] = convertLegacyKeyToKeyAndOctave(rawKeyIndex);
                    this.key = key;
                    this.octave = octave;
                } else {
                    this.key = clamp(0, Config.keys.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                    this.octave = clamp(Config.octaveMin, Config.octaveMax + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + Config.octaveMin);
                }
                URLDebugger.log("k", "key", startIndex, charIndex, { key: this.key, octave: this.octave });
            } break;
            case SongTagCode.loopStart: {
                const startIndex = charIndex;
                if (beforeFive && fromBeepBox) {
                    this.loopStart = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                } else {
                    this.loopStart = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                }
                URLDebugger.log("l", "loopStart", startIndex, charIndex, this.loopStart);
            } break;
            case SongTagCode.loopEnd: {
                const startIndex = charIndex;
                if (beforeFive && fromBeepBox) {
                    this.loopLength = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                } else {
                    this.loopLength = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1;
                }
                URLDebugger.log("e", "loopEnd", startIndex, charIndex, this.loopLength);
            } break;
            case SongTagCode.tempo: {
                const startIndex = charIndex;
                if (beforeFour && fromBeepBox) {
                    this.tempo = [95, 120, 151, 190][base64CharCodeToInt[compressed.charCodeAt(charIndex++)]];
                } else if (beforeSeven && fromBeepBox) {
                    this.tempo = [88, 95, 103, 111, 120, 130, 140, 151, 163, 176, 190, 206, 222, 240, 259][base64CharCodeToInt[compressed.charCodeAt(charIndex++)]];
                } else {
                    this.tempo = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) | (base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                }
                this.tempo = clamp(Config.tempoMin, Config.tempoMax + 1, this.tempo);
                URLDebugger.log("t", "tempo", startIndex, charIndex, this.tempo);
            } break;
            case SongTagCode.reverb: {
                const startIndex = charIndex;
                if (beforeNine && fromBeepBox) {
                    legacyGlobalReverb = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * 12;
                    legacyGlobalReverb = clamp(0, Config.reverbRange, legacyGlobalReverb);
                } else if ((fromJummBox && beforeFive) || (beforeFour && fromGoldBox)) {
                    legacyGlobalReverb = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                    legacyGlobalReverb = clamp(0, Config.reverbRange, legacyGlobalReverb);
                } else {
                    // Do nothing, BeepBox v9+ do not support song-wide reverb - JummBox still does via modulator.
                }
                URLDebugger.log("m", "reverb", startIndex, charIndex, legacyGlobalReverb);
            } break;
            case SongTagCode.beatCount: {
                const startIndex = charIndex;
                if (beforeThree && fromBeepBox) {
                    this.beatsPerBar = [6, 7, 8, 9, 10][base64CharCodeToInt[compressed.charCodeAt(charIndex++)]];
                } else {
                    this.beatsPerBar = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1;
                }
                this.beatsPerBar = Math.max(Config.beatsPerBarMin, Math.min(Config.beatsPerBarMax, this.beatsPerBar));
                URLDebugger.log("a", "beatCount", startIndex, charIndex, this.beatsPerBar);
            } break;
            case SongTagCode.barCount: {
                const startIndex = charIndex;
                const barCount: number = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1;
                this.barCount = validateRange(Config.barCountMin, Config.barCountMax, barCount);
                for (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {
                    for (let bar = this.channels[channelIndex].bars.length; bar < this.barCount; bar++) {
                        this.channels[channelIndex].bars[bar] = (bar < 4) ? 1 : 0;
                    }
                    this.channels[channelIndex].bars.length = this.barCount;
                }
                URLDebugger.log("g", "barCount", startIndex, charIndex, this.barCount);
            } break;
            case SongTagCode.patternCount: {
                const startIndex = charIndex;
                let patternsPerChannel: number;
                if (beforeEight && fromBeepBox) {
                    patternsPerChannel = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1;
                } else {
                    patternsPerChannel = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1;
                }
                this.patternsPerChannel = validateRange(1, Config.barCountMax, patternsPerChannel);
                const channelCount: number = this.getChannelCount();
                for (let channelIndex: number = 0; channelIndex < channelCount; channelIndex++) {
                    const patterns: Pattern[] = this.channels[channelIndex].patterns;
                    for (let pattern = patterns.length; pattern < this.patternsPerChannel; pattern++) {
                        patterns[pattern] = new Pattern();
                    }
                    patterns.length = this.patternsPerChannel;
                }
                URLDebugger.log("j", "patternCount", startIndex, charIndex, this.patternsPerChannel);
            } break;
            case SongTagCode.instrumentCount: {
                const startIndex = charIndex;
                if (fromSomethingBox) {
                    const instrumentsFlagBits: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                    this.layeredInstruments = (instrumentsFlagBits & (1 << 1)) != 0;
                    this.patternInstruments = (instrumentsFlagBits & (1 << 0)) != 0;
                                       // Always loop through channels to ensure instruments are created.
                                       for (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {
                                           let instrumentCount: number = 1; // Default to 1 instrument per channel.
                                           if (this.layeredInstruments || this.patternInstruments) {
                                               // If flags are true, read the real count from the data stream.
                                               instrumentCount = validateRange(Config.instrumentCountMin, this.getMaxInstrumentsPerChannel(), base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + Config.instrumentCountMin);
                                           }
                                           const channel: Channel = this.channels[channelIndex];
                                           const isNoiseChannel: boolean = channel.type === ChannelType.Noise;
                                           const isModChannel: boolean = channel.type === ChannelType.Mod;
                                           for (let i: number = channel.instruments.length; i < instrumentCount; i++) {
                                               channel.instruments[i] = new Instrument(isNoiseChannel, isModChannel);
                                           }
                                           channel.instruments.length = instrumentCount;
                                        }
                                        } else { // All legacy formats
                        const instrumentsPerChannel: number = validateRange(Config.instrumentCountMin, Config.patternInstrumentCountMax, base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + Config.instrumentCountMin);
                        this.layeredInstruments = false;
                        this.patternInstruments = (instrumentsPerChannel > 1);

                        for (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {
                            const isNoiseChannel: boolean = this.getChannelIsNoise(channelIndex);
                            const isModChannel: boolean = this.getChannelIsMod(channelIndex);

                            for (let instrumentIndex: number = this.channels[channelIndex].instruments.length; instrumentIndex < instrumentsPerChannel; instrumentIndex++) {
                                this.channels[channelIndex].instruments[instrumentIndex] = new Instrument(isNoiseChannel, isModChannel);
                            }
                            this.channels[channelIndex].instruments.length = instrumentsPerChannel;
                            if (beforeSix && fromBeepBox) {
                                for (let instrumentIndex: number = 0; instrumentIndex < instrumentsPerChannel; instrumentIndex++) {
                                    this.channels[channelIndex].instruments[instrumentIndex].setTypeAndReset(isNoiseChannel ? InstrumentType.noise : InstrumentType.chip, isNoiseChannel, isModChannel);
                                }
                            }

                            for (let j: number = legacySettingsCache![channelIndex].length; j < instrumentsPerChannel; j++) {
                                legacySettingsCache![channelIndex][j] = {};
                            }
                        }
                    }
                    URLDebugger.log("i", "instrumentCount", startIndex, charIndex, { layered: this.layeredInstruments, pattern: this.patternInstruments });
            } break;
            case SongTagCode.rhythm: {
                const startIndex = charIndex;
               if (fromSomethingBox) {
                   this.rhythm = clamp(0, Config.rhythms.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
               } else if (!fromUltraBox && !fromSlarmoosBox && !fromSomethingBox) {
                    let newRhythm = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                    this.rhythm = clamp(0, Config.rhythms.length, newRhythm);
                    if (fromJummBox && beforeThree || fromBeepBox) {
                        if (this.rhythm == Config.rhythms.dictionary["÷3 (triplets)"].index || this.rhythm == Config.rhythms.dictionary["÷6"].index) {
                            useSlowerArpSpeed = true;
                        }
                        if (this.rhythm >= Config.rhythms.dictionary["÷6"].index) {
                            // @TODO: This assumes that 6 and 8 are in that order, but
                            // if someone reorders Config.rhythms that may not be true,
                            // so this check probably should instead look for those
                            // specific rhythms.
                            useFastTwoNoteArp = true;
                        }
                    }
                } else if ((fromSlarmoosBox && beforeFour) || (fromUltraBox && beforeFive)) {
                    const rhythmMap = [1, 1, 0, 1, 2, 3, 4, 5];
                    this.rhythm = clamp(0, Config.rhythms.length, rhythmMap[base64CharCodeToInt[compressed.charCodeAt(charIndex++)]]);
                } else {
                    this.rhythm = clamp(0, Config.rhythms.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                }
                URLDebugger.log("r", "rhythm", startIndex, charIndex, this.rhythm);
            } break;
            case SongTagCode.channelOctave: {
                const startIndex = charIndex;
               if (fromSomethingBox) {
                   this.channels.forEach(channel => {
                       if (channel.type === ChannelType.Pitch) {
                           channel.octave = clamp(0, Config.pitchOctaves, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                       } else {
                           channel.octave = 0;
                       }
                   });
               } else { 
                   if (beforeThree && fromBeepBox) {
                       const channelIndex: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                       this.channels[channelIndex].octave = clamp(0, Config.pitchOctaves, base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1);
                       if (this.getChannelIsNoise(channelIndex) || this.getChannelIsMod(channelIndex)) this.channels[channelIndex].octave = 0;
                   } else if ((beforeNine && fromBeepBox) || ((fromJummBox && beforeFive) || (beforeFour && fromGoldBox))) {
                       for (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {
                           this.channels[channelIndex].octave = clamp(0, Config.pitchOctaves, base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1);
                           if (this.getChannelIsNoise(channelIndex) || this.getChannelIsMod(channelIndex)) this.channels[channelIndex].octave = 0;
                       }
                   } else { 
						this.channels.forEach(channel => {
							if (channel.type === ChannelType.Pitch) {
								channel.octave = clamp(0, Config.pitchOctaves, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
							}
						});
                   }
                }
                URLDebugger.log("o", "channelOctave", startIndex, charIndex, this.channels.map(c => c.octave));
            } break;
            case SongTagCode.startInstrument: {
                const startIndex = charIndex;
                instrumentIndexIterator++;
                if (instrumentIndexIterator >= this.channels[instrumentChannelIterator].instruments.length) {
                    instrumentChannelIterator++;
                    instrumentIndexIterator = 0;
                }
                validateRange(0, this.channels.length - 1, instrumentChannelIterator);
                const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                // JB before v5 had custom chip and mod before pickedString and supersaw were added. Index +2.
                let instrumentType: number = validateRange(0, InstrumentType.length - 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                if ((fromJummBox && beforeFive) || (beforeFour && fromGoldBox)) {
                    if (instrumentType == InstrumentType.pickedString || instrumentType == InstrumentType.supersaw) {
                        instrumentType += 2;
                    }
                }
                // Similar story here, JB before v5 had custom chip and mod before supersaw was added. Index +1.
                else if ((fromJummBox && beforeSix) || (fromGoldBox && !beforeFour) || (fromUltraBox && beforeFive)) {
                    if (instrumentType == InstrumentType.supersaw || instrumentType == InstrumentType.customChipWave || instrumentType == InstrumentType.mod) {
                        instrumentType += 1;
                    }
                }
                instrument.setTypeAndReset(instrumentType, this.getChannelIsNoise(instrumentChannelIterator), this.getChannelIsMod(instrumentChannelIterator));

                // Anti-aliasing was added in BeepBox 3.0 (v6->v7) and JummBox 1.3 (v1->v2 roughly but some leakage possible)
                if (((beforeSeven && fromBeepBox) || (beforeTwo && fromJummBox)) && (instrumentType == InstrumentType.chip || instrumentType == InstrumentType.customChipWave || instrumentType == InstrumentType.pwm)) {
                    instrument.aliases = true;
                    instrument.distortion = 0;
                    instrument.effects |= 1 << EffectType.distortion;
                }
                if (useSlowerArpSpeed) {
                    instrument.arpeggioSpeed = 9; // x3/4 speed. This used to be tied to rhythm, but now it is decoupled to each instrument's arp speed slider. This flag gets set when importing older songs to keep things consistent.
                }
                if (useFastTwoNoteArp) {
                    instrument.fastTwoNoteArp = true;
                }

                if (beforeSeven && fromBeepBox) {
                    // instrument.effects = 0;
                    // Chip/noise instruments had arpeggio and FM had custom interval but neither
                    // explicitly saved the chorus setting beforeSeven so enable it here.
                    if (instrument.chord != Config.chords.dictionary["simultaneous"].index) {
                        // Enable chord if it was used.
                        instrument.effects |= 1 << EffectType.chord;
                    }
                }
                URLDebugger.log("T", "startInstrument", startIndex, charIndex, { channel: instrumentChannelIterator, instrument: instrumentIndexIterator, type: instrument.type });
            } break;
            case SongTagCode.preset: {
                const startIndex = charIndex;
                const presetValue: number = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) | (base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].preset = presetValue;
                // Picked string was inserted before custom chip in JB v5, so bump up preset index.
                if ((fromJummBox && beforeFive) || (beforeFour && fromGoldBox)) {
                    if (this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].preset == InstrumentType.pickedString) {
                        this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].preset = InstrumentType.customChipWave;
                        this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].type = InstrumentType.customChipWave;
                    }
                }
                // Similar story, supersaw is also before custom chip (and mod, but mods can't have presets).
                else if ((fromJummBox && beforeSix) || (fromUltraBox && beforeFive)) {
                    if (this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].preset == InstrumentType.supersaw) {
                        this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].preset = InstrumentType.customChipWave;
                        this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].type = InstrumentType.customChipWave;
                    }
                    // ultra code for 6-op fm maybe
                    if (this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].preset == InstrumentType.mod) {
                        this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].preset = InstrumentType.fm6op;
                        this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].type = InstrumentType.fm6op;
                    }
                }
                // BeepBox directly tweaked "grand piano", but JB kept it the same. The most up to date version is now "grand piano 3"
                if (fromBeepBox && presetValue == EditorConfig.nameToPresetValue("grand piano 1")) {
                    this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].preset = EditorConfig.nameToPresetValue("grand piano 3")!;
                }
                URLDebugger.log("u", "preset", startIndex, charIndex, presetValue);
            } break;
            
            case SongTagCode.wave: { // 119, which is the same as SongTagCode.pulseWidth
                const startIndex = charIndex;
                const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
 
                // First, handle the very old, self-contained BeepBox legacy formats.
                if (beforeThree && fromBeepBox) {
                    const legacyWaves: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 0];
                    const channelIndex: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                    const legacyInstrument: Instrument = this.channels[channelIndex].instruments[0];
                    legacyInstrument.chipWave = clamp(0, Config.chipWaves.length, legacyWaves[base64CharCodeToInt[compressed.charCodeAt(charIndex++)]] | 0);
                    legacyInstrument.convertLegacySettings(legacySettingsCache![channelIndex][0], forceSimpleFilter);
                } else if (beforeSix && fromBeepBox) {
                    const legacyWaves: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 0];
                    for (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {
                        for (const legacyInstrument of this.channels[channelIndex].instruments) {
                            if (this.getChannelIsNoise(channelIndex)) {
                                legacyInstrument.chipNoise = clamp(0, Config.chipNoises.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                            } else {
                                legacyInstrument.chipWave = clamp(0, Config.chipWaves.length, legacyWaves[base64CharCodeToInt[compressed.charCodeAt(charIndex++)]] | 0);
                            }
                        }
                    }
                } else if (beforeSeven && fromBeepBox) {
                    const legacyWaves: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 0];
                    if (this.getChannelIsNoise(instrumentChannelIterator)) {
                        instrument.chipNoise = clamp(0, Config.chipNoises.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                    } else {
                        instrument.chipWave = clamp(0, Config.chipWaves.length, legacyWaves[base64CharCodeToInt[compressed.charCodeAt(charIndex++)]] | 0);
                    }
                } else {
                    // This is the path for all modern formats.
                    if (instrument.type === InstrumentType.noise) {
                        instrument.chipNoise = clamp(0, Config.chipNoises.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                    
                    } else if (instrument.type === InstrumentType.pwm || instrument.type === InstrumentType.supersaw) {
                        // This is the logic from the original pulseWidth block.
                        instrument.pulseWidth = clamp(0, Config.pulseWidthRange + (+(fromJummBox)) + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                        if (fromBeepBox) {
                            instrument.pulseWidth = Math.round(Math.pow(0.5, (7 - instrument.pulseWidth) * Config.pulseWidthStepPower) * Config.pulseWidthRange);
                        }
 
                        if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox) || (beforeFour && fromGoldBox)) {
                            const pregoldToEnvelope: number[] = [0, 1, 2, 4, 5, 6, 8, 9, 10, 12, 13, 14, 16, 17, 18, 19, 20, 21, 23, 24, 25, 27, 28, 29, 32, 33, 34, 31, 11];
                            const legacySettings: LegacySettings = legacySettingsCache![instrumentChannelIterator][instrumentIndexIterator];
                            let aa: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                            if ((beforeTwo && fromGoldBox) || (!fromGoldBox && !fromUltraBox && !fromSlarmoosBox && !fromSomethingBox)) aa = pregoldToEnvelope[aa];
                            legacySettings.pulseEnvelope = Song._envelopeFromLegacyIndex(aa);
                            instrument.convertLegacySettings(legacySettings, forceSimpleFilter);
                        }
 
                        if (fromSomethingBox || (fromUltraBox && !beforeFour) || fromSlarmoosBox) {
                            instrument.decimalOffset = clamp(0, 99 + 1, (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                        }
 
                    } else {
                        // This is the logic for chip, customChipWave, etc.
                        if (fromSomethingBox || fromSlarmoosBox || fromUltraBox) {
                            const chipWaveReal = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                            const chipWaveCounter = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
 
                            if (chipWaveCounter == 3) {
                                instrument.chipWave = clamp(0, Config.chipWaves.length, chipWaveReal + 186);
                            } else if (chipWaveCounter == 2) {
                                instrument.chipWave = clamp(0, Config.chipWaves.length, chipWaveReal + 124);
                            } else if (chipWaveCounter == 1) {
                                instrument.chipWave = clamp(0, Config.chipWaves.length, chipWaveReal + 62);
                            } else {
                                instrument.chipWave = clamp(0, Config.chipWaves.length, chipWaveReal);
                            }
                        } else {
                            instrument.chipWave = clamp(0, Config.chipWaves.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                        }
                    }
                }
                URLDebugger.log("w", "wave", startIndex, charIndex, { type: instrument.type, chipWave: instrument.chipWave, chipNoise: instrument.chipNoise, pulseWidth: instrument.pulseWidth });
            } break;
            
	case SongTagCode.eqFilter: {
        const startIndex = charIndex;
        if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox) || (beforeFour && fromGoldBox)) {
            if (beforeSeven && fromBeepBox) {
                const legacyToCutoff: number[] = [10, 6, 3, 0, 8, 5, 2];
                const legacyToEnvelope: string[] = ["none", "none", "none", "none", "decay 1", "decay 2", "decay 3"];

                if (beforeThree && fromBeepBox) {
                    const channelIndex: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                    const instrument: Instrument = this.channels[channelIndex].instruments[0];
                    const legacySettings: LegacySettings = legacySettingsCache![channelIndex][0];
                    const legacyFilter: number = [1, 3, 4, 5][clamp(0, legacyToCutoff.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)])];
                    legacySettings.filterCutoff = legacyToCutoff[legacyFilter];
                    legacySettings.filterResonance = 0;
                    legacySettings.filterEnvelope = Config.envelopes.dictionary[legacyToEnvelope[legacyFilter]];
                    instrument.convertLegacySettings(legacySettings, forceSimpleFilter);
                } else if (beforeSix && fromBeepBox) {
                    for (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {
                        for (let i: number = 0; i < this.channels[channelIndex].instruments.length; i++) {
                            const instrument: Instrument = this.channels[channelIndex].instruments[i];
                            const legacySettings: LegacySettings = legacySettingsCache![channelIndex][i];
                            const legacyFilter: number = clamp(0, legacyToCutoff.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1);
                            if (!this.getChannelIsNoise(channelIndex) && !this.getChannelIsMod(channelIndex)) {
                                legacySettings.filterCutoff = legacyToCutoff[legacyFilter];
                                legacySettings.filterResonance = 0;
                                legacySettings.filterEnvelope = Config.envelopes.dictionary[legacyToEnvelope[legacyFilter]];
                            } else {
                                legacySettings.filterCutoff = 10;
                                legacySettings.filterResonance = 0;
                                legacySettings.filterEnvelope = Config.envelopes.dictionary["none"];
                            }
                            instrument.convertLegacySettings(legacySettings, forceSimpleFilter);
                        }
                    }
                } else {
                    const legacyFilter: number = clamp(0, legacyToCutoff.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                    const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                    const legacySettings: LegacySettings = legacySettingsCache![instrumentChannelIterator][instrumentIndexIterator];
                    legacySettings.filterCutoff = legacyToCutoff[legacyFilter];
                    legacySettings.filterResonance = 0;
                    legacySettings.filterEnvelope = Config.envelopes.dictionary[legacyToEnvelope[legacyFilter]];
                    instrument.convertLegacySettings(legacySettings, forceSimpleFilter);
                }
            } else {
                const filterCutoffRange: number = 11;
                const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                const legacySettings: LegacySettings = legacySettingsCache![instrumentChannelIterator][instrumentIndexIterator];
                legacySettings.filterCutoff = clamp(0, filterCutoffRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                instrument.convertLegacySettings(legacySettings, forceSimpleFilter);
            }
        } else {
            // This block handles all modern formats.
            const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
            let typeCheck: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];

            if (fromBeepBox || typeCheck == 0) {
                instrument.eqFilterType = false;
                
                if (fromJummBox || fromGoldBox || fromUltraBox || fromSlarmoosBox || fromSomethingBox) {
                    typeCheck = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                }
                
                const originalControlPointCount: number = typeCheck;
                instrument.eqFilter.controlPointCount = clamp(0, Config.filterMaxPoints + 1, originalControlPointCount);
                for (let i: number = instrument.eqFilter.controlPoints.length; i < instrument.eqFilter.controlPointCount; i++) {
                    instrument.eqFilter.controlPoints[i] = new FilterControlPoint();
                }
                for (let i: number = 0; i < instrument.eqFilter.controlPointCount; i++) {
                    const point: FilterControlPoint = instrument.eqFilter.controlPoints[i];
                    point.type = clamp(0, FilterType.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                    point.freq = clamp(0, Config.filterFreqRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                    point.gain = clamp(0, Config.filterGainRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                }
                for (let i: number = instrument.eqFilter.controlPointCount; i < originalControlPointCount; i++) {
                    charIndex += 3;
                }

                instrument.eqSubFilters[0] = instrument.eqFilter;
                if ((fromJummBox && !beforeFive) || (fromGoldBox && !beforeFour) || fromUltraBox || fromSlarmoosBox || fromSomethingBox) {
                    let usingSubFilterBitfield: number = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) | (base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                    for (let j: number = 0; j < Config.filterMorphCount - 1; j++) {
                        if (usingSubFilterBitfield & (1 << j)) {
                            const originalSubfilterControlPointCount: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                            if (instrument.eqSubFilters[j + 1] == null)
                                instrument.eqSubFilters[j + 1] = new FilterSettings();
                            instrument.eqSubFilters[j + 1]!.controlPointCount = clamp(0, Config.filterMaxPoints + 1, originalSubfilterControlPointCount);
                            for (let i: number = instrument.eqSubFilters[j + 1]!.controlPoints.length; i < instrument.eqSubFilters[j + 1]!.controlPointCount; i++) {
                                instrument.eqSubFilters[j + 1]!.controlPoints[i] = new FilterControlPoint();
                            }
                            for (let i: number = 0; i < instrument.eqSubFilters[j + 1]!.controlPointCount; i++) {
                                const point: FilterControlPoint = instrument.eqSubFilters[j + 1]!.controlPoints[i];
                                point.type = clamp(0, FilterType.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                point.freq = clamp(0, Config.filterFreqRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                point.gain = clamp(0, Config.filterGainRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                            }
                            for (let i: number = instrument.eqSubFilters[j + 1]!.controlPointCount; i < originalSubfilterControlPointCount; i++) {
                                charIndex += 3;
                            }
                        }
                    }
                }
            }
            else {
                instrument.eqFilterType = true;
                instrument.eqFilterSimpleCut = clamp(0, Config.filterSimpleCutRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                instrument.eqFilterSimplePeak = clamp(0, Config.filterSimplePeakRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
            }
            URLDebugger.log("f", "eqFilter", startIndex, charIndex, { type: instrument.eqFilterType, cut: instrument.eqFilterSimpleCut, peak: instrument.eqFilterSimplePeak, points: instrument.eqFilter.controlPointCount });
        }
    } break;
            
	
	case SongTagCode.loopControls: {
        const startIndex = charIndex;
        if (fromSomethingBox || fromSlarmoosBox || fromUltraBox) {
            if (beforeThree && fromUltraBox) {
                // Still have to support the old and bad loop control data format written as a test, sigh.
                const sampleLoopInfoEncodedLength = decode32BitNumber(compressed, charIndex);
                charIndex += 6;
                const sampleLoopInfoEncoded = compressed.slice(charIndex, charIndex + sampleLoopInfoEncodedLength);
                charIndex += sampleLoopInfoEncodedLength;
                interface SampleLoopInfo {
                    isUsingAdvancedLoopControls: boolean;
                    chipWaveLoopStart: number;
                    chipWaveLoopEnd: number;
                    chipWaveLoopMode: number;
                    chipWavePlayBackwards: boolean;
                    chipWaveStartOffset: number;
                }
                interface SampleLoopInfoEntry {
                    channel: number;
                    instrument: number;
                    info: SampleLoopInfo;
                }
                const sampleLoopInfo: SampleLoopInfoEntry[] = JSON.parse(atob(sampleLoopInfoEncoded));
                for (const entry of sampleLoopInfo) {
                    const channelIndex: number = entry["channel"];
                    const instrumentIndex: number = entry["instrument"];
                    const info: SampleLoopInfo = entry["info"];
                    const instrument: Instrument = this.channels[channelIndex].instruments[instrumentIndex];
                    instrument.isUsingAdvancedLoopControls = info["isUsingAdvancedLoopControls"];
                    instrument.chipWaveLoopStart = info["chipWaveLoopStart"];
                    instrument.chipWaveLoopEnd = info["chipWaveLoopEnd"];
                    instrument.chipWaveLoopMode = info["chipWaveLoopMode"];
                    instrument.chipWavePlayBackwards = info["chipWavePlayBackwards"];
                    instrument.chipWaveStartOffset = info["chipWaveStartOffset"];
                }
            } else {
                // Read the new loop control data format.
                const encodedLoopMode: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                const isUsingAdvancedLoopControls: boolean = Boolean(encodedLoopMode & 1);
                const chipWaveLoopMode: number = encodedLoopMode >> 1;
                const encodedReleaseMode: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                const chipWavePlayBackwards: boolean = Boolean(encodedReleaseMode & 1);
                const chipWaveLoopStart: number = decode32BitNumber(compressed, charIndex);
                charIndex += 6;
                const chipWaveLoopEnd: number = decode32BitNumber(compressed, charIndex);
                charIndex += 6;
                const chipWaveStartOffset: number = decode32BitNumber(compressed, charIndex);
                charIndex += 6;
                const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                instrument.isUsingAdvancedLoopControls = isUsingAdvancedLoopControls;
                instrument.chipWaveLoopStart = chipWaveLoopStart;
                instrument.chipWaveLoopEnd = chipWaveLoopEnd;
                instrument.chipWaveLoopMode = chipWaveLoopMode;
                instrument.chipWavePlayBackwards = chipWavePlayBackwards;
                instrument.chipWaveStartOffset = chipWaveStartOffset;
            }
        }
        else if (fromGoldBox && !beforeFour && beforeSix) {
            if (document.URL.substring(document.URL.length - 13).toLowerCase() != "legacysamples") {
                if (!willLoadLegacySamplesForOldSongs) {
                    willLoadLegacySamplesForOldSongs = true;
                    Config.willReloadForCustomSamples = true;
                    EditorConfig.customSamples = ["legacySamples"];
                    loadBuiltInSamples(0);
                }
            }
            this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].chipWave = clamp(0, Config.chipWaves.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 125);
        } else if ((beforeNine && fromBeepBox) || ((fromJummBox && beforeFive) || (beforeFour && fromGoldBox))) {
            const filterResonanceRange: number = 8;
            const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
            const legacySettings: LegacySettings = legacySettingsCache![instrumentChannelIterator][instrumentIndexIterator];
            legacySettings.filterResonance = clamp(0, filterResonanceRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
            instrument.convertLegacySettings(legacySettings, forceSimpleFilter);

        }
        URLDebugger.log("y", "loopControls", startIndex, charIndex, "Complex logic, skipped value logging.");
    } break;
            case SongTagCode.drumsetEnvelopes: {
                const startIndex = charIndex;
                const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                const pregoldToEnvelope: number[] = [0, 1, 2, 4, 5, 6, 8, 9, 10, 12, 13, 14, 16, 17, 18, 19, 20, 21, 23, 24, 25, 27, 28, 29, 32, 33, 34, 31, 11];
                if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox) || (beforeFour && fromGoldBox)) {
                    if ((beforeTwo && fromGoldBox) || (!fromGoldBox && !fromUltraBox && !fromSlarmoosBox && !fromSomethingBox)) {

                    }
                    if (instrument.type == InstrumentType.drumset) {
                        for (let i: number = 0; i < Config.drumCount; i++) {
                            let aa: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                            if ((beforeTwo && fromGoldBox) || (!fromGoldBox && !fromUltraBox && !fromSlarmoosBox && !fromSomethingBox)) aa = pregoldToEnvelope[aa];
                            instrument.drumsetEnvelopes[i] = Song._envelopeFromLegacyIndex(aa).index;
                        }
                    } else {
                        // This used to be used for general filter envelopes.
                        // The presence of an envelope affects how convertLegacySettings
                        // decides the closest possible approximation, so update it.
                        const legacySettings: LegacySettings = legacySettingsCache![instrumentChannelIterator][instrumentIndexIterator];
                        let aa: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                        if ((beforeTwo && fromGoldBox) || (!fromGoldBox && !fromUltraBox && !fromSlarmoosBox && !fromSomethingBox)) aa = pregoldToEnvelope[aa];
                        legacySettings.filterEnvelope = Song._envelopeFromLegacyIndex(aa);
                        instrument.convertLegacySettings(legacySettings, forceSimpleFilter);
                    }
                } else {
                    // In modern formats, this tag is only used for drumset filter envelopes.
                    if (instrument.type == InstrumentType.drumset) {
                        for (let i: number = 0; i < Config.drumCount; i++) {
                            let aa: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                        if (!fromSomethingBox) {
                            if ((beforeTwo && fromGoldBox) || (!fromGoldBox && !fromUltraBox && !fromSlarmoosBox)) aa = pregoldToEnvelope[aa];
                            if (!fromSlarmoosBox && aa >= 2) aa++; //2 for pitch
                        }
                        }
                    }
                }
                URLDebugger.log("z", "drumsetEnvelopes", startIndex, charIndex, "Complex logic, skipped value logging.");
            } break;
            case SongTagCode.pulseWidth: {
                const startIndex = charIndex;
                const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                instrument.pulseWidth = clamp(0, Config.pulseWidthRange + (+(fromJummBox)) + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                if (fromBeepBox) {
                    // BeepBox formula
                    instrument.pulseWidth = Math.round(Math.pow(0.5, (7 - instrument.pulseWidth) * Config.pulseWidthStepPower) * Config.pulseWidthRange);
                }
 
                if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox) || (beforeFour && fromGoldBox)) {
                    const pregoldToEnvelope: number[] = [0, 1, 2, 4, 5, 6, 8, 9, 10, 12, 13, 14, 16, 17, 18, 19, 20, 21, 23, 24, 25, 27, 28, 29, 32, 33, 34, 31, 11];
                    const legacySettings: LegacySettings = legacySettingsCache![instrumentChannelIterator][instrumentIndexIterator];
                    let aa: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                    if ((beforeTwo && fromGoldBox) || (!fromGoldBox && !fromUltraBox && !fromSlarmoosBox && !fromSomethingBox)) aa = pregoldToEnvelope[aa];
                    legacySettings.pulseEnvelope = Song._envelopeFromLegacyIndex(aa);
                    instrument.convertLegacySettings(legacySettings, forceSimpleFilter);
                }
 
                if (fromSomethingBox || (fromUltraBox && !beforeFour) || fromSlarmoosBox) {
                    instrument.decimalOffset = clamp(0, 99 + 1, (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                }
                URLDebugger.log("W", "pulseWidth", startIndex, charIndex, { width: instrument.pulseWidth, offset: instrument.decimalOffset });
            } break;

            case SongTagCode.stringSustain: {
                const startIndex = charIndex;
                const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                const sustainValue: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                instrument.stringSustain = clamp(0, Config.stringSustainRange, sustainValue & 0x1F);
                instrument.stringSustainType = Config.enableAcousticSustain ? clamp(0, SustainType.length, sustainValue >> 5) : SustainType.bright;
                URLDebugger.log("I", "stringSustain", startIndex, charIndex, { sustain: instrument.stringSustain, type: instrument.stringSustainType });
            } break;
            
	case SongTagCode.fadeInOut: {
        const startIndex = charIndex;
        if ((beforeNine && fromBeepBox) || ((fromJummBox && beforeFive) || (beforeFour && fromGoldBox))) {
            const legacySettings = [
                { transition: "interrupt", fadeInSeconds: 0.0, fadeOutTicks: -1 },
                { transition: "normal", fadeInSeconds: 0.0, fadeOutTicks: -3 },
                { transition: "normal", fadeInSeconds: 0.025, fadeOutTicks: -3 },
                { transition: "slide in pattern", fadeInSeconds: 0.025, fadeOutTicks: -3 },
                { transition: "normal", fadeInSeconds: 0.04, fadeOutTicks: 6 },
                { transition: "normal", fadeInSeconds: 0.0, fadeOutTicks: 48 },
                { transition: "normal", fadeInSeconds: 0.0125, fadeOutTicks: 72 },
                { transition: "normal", fadeInSeconds: 0.06, fadeOutTicks: 96 },
                { transition: "slide in pattern", fadeInSeconds: 0.025, fadeOutTicks: -3 },
            ];
            if (beforeThree && fromBeepBox) {
                const channelIndex: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                const settings = legacySettings[clamp(0, legacySettings.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)])];
                const instrument: Instrument = this.channels[channelIndex].instruments[0];
                instrument.fadeIn = Synth.secondsToFadeInSetting(settings.fadeInSeconds);
                instrument.fadeOut = Synth.ticksToFadeOutSetting(settings.fadeOutTicks);
                instrument.transition = Config.transitions.dictionary[settings.transition].index;
                if (instrument.transition != Config.transitions.dictionary["normal"].index) {
                    instrument.effects |= 1 << EffectType.transition;
                }
            } else if (beforeSix && fromBeepBox) {
                for (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {
                    for (const instrument of this.channels[channelIndex].instruments) {
                        const settings = legacySettings[clamp(0, legacySettings.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)])];
                        instrument.fadeIn = Synth.secondsToFadeInSetting(settings.fadeInSeconds);
                        instrument.fadeOut = Synth.ticksToFadeOutSetting(settings.fadeOutTicks);
                        instrument.transition = Config.transitions.dictionary[settings.transition].index;
                        if (instrument.transition != Config.transitions.dictionary["normal"].index) {
                            instrument.effects |= 1 << EffectType.transition;
                        }
                    }
                }
            } else if ((beforeFour && !fromGoldBox && !fromUltraBox && !fromSlarmoosBox && !fromSomethingBox) || fromBeepBox) {
                const settings = legacySettings[clamp(0, legacySettings.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)])];
                const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                instrument.fadeIn = Synth.secondsToFadeInSetting(settings.fadeInSeconds);
                instrument.fadeOut = Synth.ticksToFadeOutSetting(settings.fadeOutTicks);
                instrument.transition = Config.transitions.dictionary[settings.transition].index;
                if (instrument.transition != Config.transitions.dictionary["normal"].index) {
                    instrument.effects |= 1 << EffectType.transition;
                }
            } else {
                const settings = legacySettings[clamp(0, legacySettings.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)])];
                const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                instrument.fadeIn = Synth.secondsToFadeInSetting(settings.fadeInSeconds);
                instrument.fadeOut = Synth.ticksToFadeOutSetting(settings.fadeOutTicks);
                instrument.transition = Config.transitions.dictionary[settings.transition].index;
                if (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] > 0) {
                    instrument.legacyTieOver = true;
                }
                instrument.clicklessTransition = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] ? true : false;
                if (instrument.transition != Config.transitions.dictionary["normal"].index || instrument.clicklessTransition) {
                    instrument.effects |= 1 << EffectType.transition;
                }
            }
        } else {
            // This block handles all modern formats.
            const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
            instrument.fadeIn = clamp(0, Config.fadeInRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
            instrument.fadeOut = clamp(0, Config.fadeOutTicks.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
            
            if (fromSomethingBox || fromJummBox || fromGoldBox || fromUltraBox || fromSlarmoosBox) {
                instrument.clicklessTransition = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] ? true : false;
            }
        }
        URLDebugger.log("d", "fadeInOut", startIndex, charIndex, { fadeIn: this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].fadeIn, fadeOut: this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].fadeOut });
    } break;
    
            case SongTagCode.songEq: { //deprecated vibrato tag repurposed for songEq
                const startIndex = charIndex;
                if ((beforeNine && fromBeepBox) || ((fromJummBox && beforeFive) || (beforeFour && fromGoldBox))) {
                    if (beforeSeven && fromBeepBox) {
                        if (beforeThree && fromBeepBox) {
                            const legacyEffects: number[] = [0, 3, 2, 0];
                            const legacyEnvelopes: string[] = ["none", "none", "none", "tremolo2"];
                            const channelIndex: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                            const effect: number = clamp(0, legacyEffects.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                            const instrument: Instrument = this.channels[channelIndex].instruments[0];
                            const legacySettings: LegacySettings = legacySettingsCache![channelIndex][0];
                            instrument.vibrato = legacyEffects[effect];
                            if (legacySettings.filterEnvelope == undefined || legacySettings.filterEnvelope.type == EnvelopeType.none) {
                                // Imitate the legacy tremolo with a filter envelope.
                                legacySettings.filterEnvelope = Config.envelopes.dictionary[legacyEnvelopes[effect]];
                                instrument.convertLegacySettings(legacySettings, forceSimpleFilter);
                            }
                            if (instrument.vibrato != Config.vibratos.dictionary["none"].index) {
                                // Enable vibrato if it was used.
                                instrument.effects |= 1 << EffectType.vibrato;
                            }
                        } else if (beforeSix && fromBeepBox) {
                            const legacyEffects: number[] = [0, 1, 2, 3, 0, 0];
                            const legacyEnvelopes: string[] = ["none", "none", "none", "none", "tremolo5", "tremolo2"];
                            for (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {
                                for (let i: number = 0; i < this.channels[channelIndex].instruments.length; i++) {
                                    const effect: number = clamp(0, legacyEffects.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                    const instrument: Instrument = this.channels[channelIndex].instruments[i];
                                    const legacySettings: LegacySettings = legacySettingsCache![channelIndex][i];
                                    instrument.vibrato = legacyEffects[effect];
                                    if (legacySettings.filterEnvelope == undefined || legacySettings.filterEnvelope.type == EnvelopeType.none) {
                                        // Imitate the legacy tremolo with a filter envelope.
                                        legacySettings.filterEnvelope = Config.envelopes.dictionary[legacyEnvelopes[effect]];
                                        instrument.convertLegacySettings(legacySettings, forceSimpleFilter);
                                    }
                                    if (instrument.vibrato != Config.vibratos.dictionary["none"].index) {
                                        // Enable vibrato if it was used.
                                        instrument.effects |= 1 << EffectType.vibrato;
                                    }
                                    if ((legacyGlobalReverb != 0 || ((fromJummBox && beforeFive) || (beforeFour && fromGoldBox))) && !this.getChannelIsNoise(channelIndex)) {
                                        // Enable reverb if it was used globaly before. (Global reverb was added before the effects option so I need to pick somewhere else to initialize instrument reverb, and I picked the vibrato command.)
                                        instrument.effects |= 1 << EffectType.reverb;
                                        instrument.reverb = legacyGlobalReverb;
                                    }
                                }
                            }
                        } else {
                            const legacyEffects: number[] = [0, 1, 2, 3, 0, 0];
                            const legacyEnvelopes: string[] = ["none", "none", "none", "none", "tremolo5", "tremolo2"];
                            const effect: number = clamp(0, legacyEffects.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                            const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                            const legacySettings: LegacySettings = legacySettingsCache![instrumentChannelIterator][instrumentIndexIterator];
                            instrument.vibrato = legacyEffects[effect];
                            if (legacySettings.filterEnvelope == undefined || legacySettings.filterEnvelope.type == EnvelopeType.none) {
                                // Imitate the legacy tremolo with a filter envelope.
                                legacySettings.filterEnvelope = Config.envelopes.dictionary[legacyEnvelopes[effect]];
                                instrument.convertLegacySettings(legacySettings, forceSimpleFilter);
                            }
                            if (instrument.vibrato != Config.vibratos.dictionary["none"].index) {
                                // Enable vibrato if it was used.
                                instrument.effects |= 1 << EffectType.vibrato;
                            }
                            if (legacyGlobalReverb != 0 || ((fromJummBox && beforeFive) || (beforeFour && fromGoldBox))) {
                                // Enable reverb if it was used globaly before. (Global reverb was added before the effects option so I need to pick somewhere else to initialize instrument reverb, and I picked the vibrato command.)
                                instrument.effects |= 1 << EffectType.reverb;
                                instrument.reverb = legacyGlobalReverb;
                            }
                        }
                    } else {
                        const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                        const vibrato: number = clamp(0, Config.vibratos.length + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                        instrument.vibrato = vibrato;
                        if (instrument.vibrato != Config.vibratos.dictionary["none"].index) {
                            // Enable vibrato if it was used.
                            instrument.effects |= 1 << EffectType.vibrato;
                        }
                        // Custom vibrato
                        if (vibrato == Config.vibratos.length) {
                            instrument.vibratoDepth = clamp(0, Config.modulators.dictionary["vibrato depth"].maxRawVol + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]) / 50;
                            instrument.vibratoSpeed = clamp(0, Config.modulators.dictionary["vibrato speed"].maxRawVol + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                            instrument.vibratoDelay = clamp(0, Config.modulators.dictionary["vibrato delay"].maxRawVol + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]) / 2;
                            instrument.vibratoType = clamp(0, Config.vibratoTypes.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                            instrument.effects |= 1 << EffectType.vibrato;
                        }
                        // Enforce standard vibrato settings
                        else {
                            instrument.vibratoDepth = Config.vibratos[instrument.vibrato].amplitude;
                            instrument.vibratoSpeed = 10; // Normal speed
                            instrument.vibratoDelay = Config.vibratos[instrument.vibrato].delayTicks / 2;
                            instrument.vibratoType = Config.vibratos[instrument.vibrato].type;
                        }
                    }
                } else {
                    // songeq
                   const originalControlPointCount: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                   this.eqFilter.controlPointCount = clamp(0, Config.filterMaxPoints + 1, originalControlPointCount);
                   for (let i: number = this.eqFilter.controlPoints.length; i < this.eqFilter.controlPointCount; i++) {
                       this.eqFilter.controlPoints[i] = new FilterControlPoint();
                   }
                   for (let i: number = 0; i < this.eqFilter.controlPointCount; i++) {
                       const point: FilterControlPoint = this.eqFilter.controlPoints[i];
                       point.type = clamp(0, FilterType.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                       point.freq = clamp(0, Config.filterFreqRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                       point.gain = clamp(0, Config.filterGainRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                   }
                   for (let i: number = this.eqFilter.controlPointCount; i < originalControlPointCount; i++) {
                       charIndex += 3;
                   }

                   // Get subfilters as well. Skip Index 0, is a copy of the base filter.
                   this.eqSubFilters[0] = this.eqFilter;

                   if (fromSomethingBox || (fromSlarmoosBox && !beforeFour)) {
                       let usingSubFilterBitfield: number = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) | (base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                       for (let j: number = 0; j < Config.filterMorphCount - 1; j++) {
                           if (usingSubFilterBitfield & (1 << j)) {
                               const originalSubfilterControlPointCount: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                               if (this.eqSubFilters[j + 1] == null)
                                   this.eqSubFilters[j + 1] = new FilterSettings();
                               this.eqSubFilters[j + 1]!.controlPointCount = clamp(0, Config.filterMaxPoints + 1, originalSubfilterControlPointCount);
                               for (let i: number = this.eqSubFilters[j + 1]!.controlPoints.length; i < this.eqSubFilters[j + 1]!.controlPointCount; i++) {
                                   this.eqSubFilters[j + 1]!.controlPoints[i] = new FilterControlPoint();
                               }
                               for (let i: number = 0; i < this.eqSubFilters[j + 1]!.controlPointCount; i++) {
                                   const point: FilterControlPoint = this.eqSubFilters[j + 1]!.controlPoints[i];
                                   point.type = clamp(0, FilterType.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                   point.freq = clamp(0, Config.filterFreqRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                   point.gain = clamp(0, Config.filterGainRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                               }
                               for (let i: number = this.eqSubFilters[j + 1]!.controlPointCount; i < originalSubfilterControlPointCount; i++) {
                                   charIndex += 3;
                               }
                           }
                       }
                   }
               }
               URLDebugger.log("c", "songEq", startIndex, charIndex, "skipped value logging for this");
           } break;
            case SongTagCode.arpeggioSpeed: {
                const startIndex = charIndex;
                // Deprecated, but supported for legacy purposes
                if ((fromJummBox && beforeFive) || (beforeFour && fromGoldBox)) {
                    const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                    instrument.arpeggioSpeed = clamp(0, Config.modulators.dictionary["arp speed"].maxRawVol + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                    instrument.fastTwoNoteArp = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] ? true : false; // Two note arp setting piggybacks on this
                }
                else {
                    // Do nothing, deprecated for now
                }
                URLDebugger.log("G", "arpeggioSpeed", startIndex, charIndex, "Legacy tag, skipped value logging.");
            } break;
            case SongTagCode.unison: {
                const startIndex = charIndex;
                if (beforeThree && fromBeepBox) {
                    const channelIndex: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                    const instrument = this.channels[channelIndex].instruments[0];
                    instrument.unison = clamp(0, Config.unisons.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                    instrument.unisonVoices = Config.unisons[instrument.unison].voices;
                    instrument.unisonSpread = Config.unisons[instrument.unison].spread;
                    instrument.unisonOffset = Config.unisons[instrument.unison].offset;
                    instrument.unisonExpression = Config.unisons[instrument.unison].expression;
                    instrument.unisonSign = Config.unisons[instrument.unison].sign;
                } else if (beforeSix && fromBeepBox) {
                    for (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {
                        for (const instrument of this.channels[channelIndex].instruments) {
                            const originalValue: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                            let unison: number = clamp(0, Config.unisons.length, originalValue);
                            if (originalValue == 8) {
                                // original "custom harmony" now maps to "hum" and "custom interval".
                                unison = 2;
                                instrument.chord = 3;
                            }
                            instrument.unison = unison;
                            instrument.unisonVoices = Config.unisons[instrument.unison].voices;
                            instrument.unisonSpread = Config.unisons[instrument.unison].spread;
                            instrument.unisonOffset = Config.unisons[instrument.unison].offset;
                            instrument.unisonExpression = Config.unisons[instrument.unison].expression;
                            instrument.unisonSign = Config.unisons[instrument.unison].sign;
                        }
                    }
                } else if (beforeSeven && fromBeepBox) {
                    const originalValue: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                    let unison: number = clamp(0, Config.unisons.length, originalValue);
                    const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                    if (originalValue == 8) {
                        // original "custom harmony" now maps to "hum" and "custom interval".
                        unison = 2;
                        instrument.chord = 3;
                    }
                    instrument.unison = unison;
                    instrument.unisonVoices = Config.unisons[instrument.unison].voices;
                    instrument.unisonSpread = Config.unisons[instrument.unison].spread;
                    instrument.unisonOffset = Config.unisons[instrument.unison].offset;
                    instrument.unisonExpression = Config.unisons[instrument.unison].expression;
                    instrument.unisonSign = Config.unisons[instrument.unison].sign;
                } else {
                    const instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                    instrument.unison = clamp(0, Config.unisons.length + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                    const unisonLength = (beforeFive || !fromSlarmoosBox && !fromSomethingBox) ? 27 : Config.unisons.length; //27 was the old length before I added >2 voice presets
                    if (((fromUltraBox && !beforeFive) || fromSlarmoosBox) && (instrument.unison == unisonLength)) {
                        // if (instrument.unison == Config.unisons.length) {
                        instrument.unison = Config.unisons.length;
                        instrument.unisonVoices = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];

                        const unisonSpreadNegative = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                        const unisonSpread: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + ((base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * 63)) * 63);

                        const unisonOffsetNegative = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                        const unisonOffset: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + ((base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * 63)) * 63);

                        const unisonExpressionNegative = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                        const unisonExpression: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * 63);

                        const unisonSignNegative = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                        const unisonSign: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * 63);


                        instrument.unisonSpread = unisonSpread / 1000;
                        if (unisonSpreadNegative == 0) instrument.unisonSpread *= -1;

                        instrument.unisonOffset = unisonOffset / 1000;
                        if (unisonOffsetNegative == 0) instrument.unisonOffset *= -1;

                        instrument.unisonExpression = unisonExpression / 1000;
                        if (unisonExpressionNegative == 0) instrument.unisonExpression *= -1;

                        instrument.unisonSign = unisonSign / 1000;
                        if (unisonSignNegative == 0) instrument.unisonSign *= -1;
                    } else {
                        instrument.unisonVoices = Config.unisons[instrument.unison].voices;
                        instrument.unisonSpread = Config.unisons[instrument.unison].spread;
                        instrument.unisonOffset = Config.unisons[instrument.unison].offset;
                        instrument.unisonExpression = Config.unisons[instrument.unison].expression;
                        instrument.unisonSign = Config.unisons[instrument.unison].sign;
                    }
                }
                URLDebugger.log("h", "unison", startIndex, charIndex, "Complex logic, skipped value logging.");
            } break;
            case SongTagCode.chord: {
                const startIndex = charIndex;
                if ((beforeNine && fromBeepBox) || ((fromJummBox && beforeFive) || (beforeFour && fromGoldBox))) {
                    const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                    instrument.chord = clamp(0, Config.chords.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                    if (instrument.chord != Config.chords.dictionary["simultaneous"].index) {
                        // Enable chord if it was used.
                        instrument.effects |= 1 << EffectType.chord;
                    }
                } else {
                    // Do nothing? This song tag code is deprecated for now.
                }
                URLDebugger.log("C", "chord", startIndex, charIndex, "Legacy tag, skipped value logging.");
            } break;
            
	
            
            case SongTagCode.effects: {
                const startIndex = charIndex;
                const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                if ((beforeNine && fromBeepBox) || ((fromJummBox && beforeFive) || (beforeFour && fromGoldBox))) {
                    instrument.effects = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] & ((1 << EffectType.length) - 1));
                    if (legacyGlobalReverb == 0 && !((fromJummBox && beforeFive) || (beforeFour && fromGoldBox))) {
                        instrument.effects &= ~(1 << EffectType.reverb);
                    } else if (effectsIncludeReverb(instrument.effects)) {
                        instrument.reverb = legacyGlobalReverb;
                    }
                    instrument.effects |= 1 << EffectType.panning;
                    if (instrument.vibrato != Config.vibratos.dictionary["none"].index) {
                        instrument.effects |= 1 << EffectType.vibrato;
                    }
                    if (instrument.detune != Config.detuneCenter) {
                        instrument.effects |= 1 << EffectType.detune;
                    }
                    if (instrument.aliases)
                        instrument.effects |= 1 << EffectType.distortion;
                    else
                        instrument.effects &= ~(1 << EffectType.distortion);
                    const legacySettings: LegacySettings = legacySettingsCache![instrumentChannelIterator][instrumentIndexIterator];
                    instrument.convertLegacySettings(legacySettings, forceSimpleFilter);
                } else {
                    // This block handles all modern formats.
                    if (EffectType.length > 18) throw new Error("EffectType bitmask exceeds 3 characters.");
 
                    if (fromSomethingBox || (fromSlarmoosBox && !beforeFive)) {
                        instrument.effects = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 12) | (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) | (base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                    } else {
                        instrument.effects = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) | (base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                    }
 
                    if (effectsIncludeNoteFilter(instrument.effects)) {
                        let typeCheck: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                        if (fromBeepBox || typeCheck == 0) {
                            instrument.noteFilterType = false;
                            
                            if (fromJummBox || fromGoldBox || fromUltraBox || fromSlarmoosBox || fromSomethingBox) {
                                typeCheck = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                            }
 
                            instrument.noteFilter.controlPointCount = clamp(0, Config.filterMaxPoints + 1, typeCheck);
                            for (let i: number = instrument.noteFilter.controlPoints.length; i < instrument.noteFilter.controlPointCount; i++) {
                                instrument.noteFilter.controlPoints[i] = new FilterControlPoint();
                            }
                            for (let i: number = 0; i < instrument.noteFilter.controlPointCount; i++) {
                                const point: FilterControlPoint = instrument.noteFilter.controlPoints[i];
                                point.type = clamp(0, FilterType.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                point.freq = clamp(0, Config.filterFreqRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                point.gain = clamp(0, Config.filterGainRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                            }
                            for (let i: number = instrument.noteFilter.controlPointCount; i < typeCheck; i++) {
                                charIndex += 3;
                            }
                            instrument.noteSubFilters[0] = instrument.noteFilter;
                            if ((fromJummBox && !beforeFive) || (fromGoldBox) || (fromUltraBox) || (fromSlarmoosBox) || fromSomethingBox) {
                                let usingSubFilterBitfield: number = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) | (base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                for (let j: number = 0; j < Config.filterMorphCount - 1; j++) {
                                    if (usingSubFilterBitfield & (1 << j)) {
                                        const originalSubfilterControlPointCount: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                                        if (instrument.noteSubFilters[j + 1] == null)
                                            instrument.noteSubFilters[j + 1] = new FilterSettings();
                                        instrument.noteSubFilters[j + 1]!.controlPointCount = clamp(0, Config.filterMaxPoints + 1, originalSubfilterControlPointCount);
                                        for (let i: number = instrument.noteSubFilters[j + 1]!.controlPoints.length; i < instrument.noteSubFilters[j + 1]!.controlPointCount; i++) {
                                            instrument.noteSubFilters[j + 1]!.controlPoints[i] = new FilterControlPoint();
                                        }
                                        for (let i: number = 0; i < instrument.noteSubFilters[j + 1]!.controlPointCount; i++) {
                                            const point: FilterControlPoint = instrument.noteSubFilters[j + 1]!.controlPoints[i];
                                            point.type = clamp(0, FilterType.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                            point.freq = clamp(0, Config.filterFreqRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                            point.gain = clamp(0, Config.filterGainRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                                        }
                                        for (let i: number = instrument.noteSubFilters[j + 1]!.controlPointCount; i < originalSubfilterControlPointCount; i++) {
                                            charIndex += 3;
                                        }
                                    }
                                }
                            }
                        } else {
                            instrument.noteFilterType = true;
                            instrument.noteFilter.reset();
                            instrument.noteFilterSimpleCut = clamp(0, Config.filterSimpleCutRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                            instrument.noteFilterSimplePeak = clamp(0, Config.filterSimplePeakRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                        }
                    }
                    if (effectsIncludeTransition(instrument.effects)) {
                        instrument.transition = clamp(0, Config.transitions.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                    }
                    if (effectsIncludeDiscreteSlide(instrument.effects)) {
                        instrument.discreteSlide = clamp(0, Config.discreteSlideTypes.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                    }
                    if (effectsIncludeChord(instrument.effects)) {
                        instrument.chord = clamp(0, Config.chords.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                        if (instrument.chord == Config.chords.dictionary["arpeggio"].index && (fromJummBox || fromGoldBox || fromUltraBox || fromSlarmoosBox || fromSomethingBox)) {
                            instrument.arpeggioSpeed = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                            instrument.fastTwoNoteArp = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)]) ? true : false;
                        }
                        if (instrument.chord == Config.chords.dictionary["monophonic"].index && ((fromSlarmoosBox && !beforeFive) || fromSomethingBox)) {
                            instrument.monoChordTone = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                        }
                    }
                    if (effectsIncludePitchShift(instrument.effects)) {
                        instrument.pitchShift = clamp(0, Config.pitchShiftRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                    }
                    if (effectsIncludeDetune(instrument.effects)) {
                        if (fromBeepBox) {
                            instrument.detune = clamp(Config.detuneMin, Config.detuneMax + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                            instrument.detune = Math.round((instrument.detune - 9) * (Math.abs(instrument.detune - 9) + 1) / 2 + Config.detuneCenter);
                        } else {
                            instrument.detune = clamp(Config.detuneMin, Config.detuneMax + 1, (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                        }
                    }
                    if (effectsIncludeVibrato(instrument.effects)) {
                        instrument.vibrato = clamp(0, Config.vibratos.length + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                        if (instrument.vibrato == Config.vibratos.length && (fromJummBox || fromGoldBox || fromUltraBox || fromSlarmoosBox || fromSomethingBox)) {
                            instrument.vibratoDepth = clamp(0, Config.modulators.dictionary["vibrato depth"].maxRawVol + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]) / 25;
                            instrument.vibratoSpeed = clamp(0, Config.modulators.dictionary["vibrato speed"].maxRawVol + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                            instrument.vibratoDelay = clamp(0, Config.modulators.dictionary["vibrato delay"].maxRawVol + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                            instrument.vibratoType = clamp(0, Config.vibratoTypes.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                        }
                        else {
                            instrument.vibratoDepth = Config.vibratos[instrument.vibrato].amplitude;
                            instrument.vibratoSpeed = 10;
                            instrument.vibratoDelay = Config.vibratos[instrument.vibrato].delayTicks / 2;
                            instrument.vibratoType = Config.vibratos[instrument.vibrato].type;
                        }
                    }
                    if (effectsIncludeDistortion(instrument.effects)) {
                        instrument.distortion = clamp(0, Config.distortionRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                        if ((fromJummBox && !beforeFive) || fromGoldBox || fromUltraBox || fromSlarmoosBox || fromSomethingBox)
                            instrument.aliases = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] ? true : false;
                    }
                    if (effectsIncludeBitcrusher(instrument.effects)) {
                        instrument.bitcrusherFreq = clamp(0, Config.bitcrusherFreqRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                        instrument.bitcrusherQuantization = clamp(0, Config.bitcrusherQuantizationRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                    }
                    if (effectsIncludePanning(instrument.effects)) {
                        if (fromBeepBox) {
                            instrument.pan = clamp(0, Config.panMax + 1, Math.round(base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * ((Config.panMax) / 8.0)));
                        }
                        else {
                            instrument.pan = clamp(0, Config.panMax + 1, (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                        }
                        if ((fromJummBox && !beforeTwo) || fromGoldBox || fromUltraBox || fromSlarmoosBox || fromSomethingBox)
                            instrument.panDelay = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                    }
                    if (effectsIncludeChorus(instrument.effects)) {
                        if (fromBeepBox) {
                            instrument.chorus = clamp(0, (Config.chorusRange / 2) + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]) * 2;
                        }
                        else {
                            instrument.chorus = clamp(0, Config.chorusRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                        }
                    }
                    if (effectsIncludeEcho(instrument.effects)) {
                        instrument.echoSustain = clamp(0, Config.echoSustainRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                        instrument.echoDelay = clamp(0, Config.echoDelayRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                    }
                    if (effectsIncludeReverb(instrument.effects)) {
                        if (fromBeepBox) {
                            instrument.reverb = clamp(0, Config.reverbRange, Math.round(base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * Config.reverbRange / 3.0));
                        } else {
                            instrument.reverb = clamp(0, Config.reverbRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                        }
                    }
                    if (effectsIncludeGranular(instrument.effects)) {
                        instrument.granular = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                        instrument.grainSize = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                        instrument.grainAmounts = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                        instrument.grainRange = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                    }
                    if (effectsIncludeRingModulation(instrument.effects)) {
                        instrument.ringModulation = clamp(0, Config.ringModRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                        instrument.ringModulationHz = clamp(0, Config.ringModHzRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                        instrument.ringModWaveformIndex = clamp(0, Config.operatorWaves.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                        instrument.ringModPulseWidth = clamp(0, Config.pulseWidthRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                        instrument.ringModHzOffset = clamp(Config.rmHzOffsetMin, Config.rmHzOffsetMax + 1, (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                    }
                }
                instrument.effects &= (1 << EffectType.length) - 1;
                URLDebugger.log("q", "effects", startIndex, charIndex, "Complex logic, skipped value logging.");
            } break;
            case SongTagCode.volume: {
                const startIndex = charIndex;
                if (beforeThree && fromBeepBox) {
                    const channelIndex: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                    const instrument: Instrument = this.channels[channelIndex].instruments[0];
                    instrument.volume = Math.round(clamp(-Config.volumeRange / 2, 1, -base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * 5.0));
                } else if (beforeSix && fromBeepBox) {
                    for (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {
                        for (const instrument of this.channels[channelIndex].instruments) {
                            instrument.volume = Math.round(clamp(-Config.volumeRange / 2, 1, -base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * 5.0));
                        }
                    }
                } else if (beforeSeven && fromBeepBox) {
                    const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                    instrument.volume = Math.round(clamp(-Config.volumeRange / 2, 1, -base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * 5.0));
                } else if (fromBeepBox) {
                    // Beepbox v9's volume range is 0-7 (0 is max, 7 is mute)
                    const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                    instrument.volume = Math.round(clamp(-Config.volumeRange / 2, 1, -base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * 25.0 / 7.0));
                } else {
                    const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                    // Volume is stored in two bytes in jummbox just in case range ever exceeds one byte, e.g. through later waffling on the subject.
                    instrument.volume = Math.round(clamp(-Config.volumeRange / 2, Config.volumeRange / 2 + 1, ((base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) | (base64CharCodeToInt[compressed.charCodeAt(charIndex++)])) - Config.volumeRange / 2));
                }
                URLDebugger.log("v", "volume", startIndex, charIndex, this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].volume);
            } break;
            case SongTagCode.pan: {
                const startIndex = charIndex;
                if (beforeNine && fromBeepBox) {
                    // Beepbox has a panMax of 8 (9 total positions), Jummbox has a panMax of 100 (101 total positions)
                    const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                    instrument.pan = clamp(0, Config.panMax + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * ((Config.panMax) / 8.0));
                } else if ((fromJummBox && beforeFive) || (beforeFour && fromGoldBox)) {
                    const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                    instrument.pan = clamp(0, Config.panMax + 1, (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                    // Pan delay follows on v3 + v4
                    if (fromJummBox && !beforeThree || fromGoldBox || fromUltraBox || fromSlarmoosBox) {
                        instrument.panDelay = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                    }
                } else {
                    // Do nothing? This song tag code is deprecated for now.
                }
                URLDebugger.log("L", "pan", startIndex, charIndex, "Legacy tag, skipped value logging.");
            } break;
            case SongTagCode.detune: {
                const startIndex = charIndex;
                const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];

                if ((fromJummBox && beforeFive) || (beforeFour && fromGoldBox)) {
                    // Before jummbox v5, detune was -50 to 50. Now it is 0 to 400
                    instrument.detune = clamp(Config.detuneMin, Config.detuneMax + 1, ((base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)]) * 4);
                    instrument.effects |= 1 << EffectType.detune;
                } else {
                    // Now in v5, tag code is deprecated and handled thru detune effects.
                }
                URLDebugger.log("D", "detune", startIndex, charIndex, "Legacy tag, skipped value logging.");
            } break;
            case SongTagCode.customChipWave: {
                const startIndex = charIndex;
                let instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                // Pop custom wave values
                for (let j: number = 0; j < 64; j++) {
                    instrument.customChipWave[j]
                        = clamp(-24, 25, base64CharCodeToInt[compressed.charCodeAt(charIndex++)] - 24);
                }

                let sum: number = 0.0;
                for (let i: number = 0; i < instrument.customChipWave.length; i++) {
                    sum += instrument.customChipWave[i];
                }
                const average: number = sum / instrument.customChipWave.length;

                // Perform the integral on the wave. The chipSynth will perform the derivative to get the original wave back but with antialiasing.
                let cumulative: number = 0;
                let wavePrev: number = 0;
                for (let i: number = 0; i < instrument.customChipWave.length; i++) {
                    cumulative += wavePrev;
                    wavePrev = instrument.customChipWave[i] - average;
                    instrument.customChipWaveIntegral[i] = cumulative;
                }

                // 65th, last sample is for anti-aliasing
                instrument.customChipWaveIntegral[64] = 0.0;
                URLDebugger.log("M", "customChipWave", startIndex, charIndex, "Skipped value logging.");
            } break;
            case SongTagCode.limiterSettings: {
                const startIndex = charIndex;
                let nextValue: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];

                // Check if limiter settings are used... if not, restore to default
                if (nextValue == 0x3f) {
                    this.restoreLimiterDefaults();
                }
                else {
                    // Limiter is used, grab values
                    this.compressionRatio = (nextValue < 10 ? nextValue / 10 : (1 + (nextValue - 10) / 60));
                    nextValue = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                    this.limitRatio = (nextValue < 10 ? nextValue / 10 : (nextValue - 9));
                    this.limitDecay = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];
                    this.limitRise = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * 250.0) + 2000.0;
                    this.compressionThreshold = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] / 20.0;
                    this.limitThreshold = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] / 20.0;
                    this.masterGain = ((base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)]) / 50.0;
                }
                URLDebugger.log("O", "limiterSettings", startIndex, charIndex, "Skipped value logging.");
            } break;
            case SongTagCode.channelNames: {
                const startIndex = charIndex;
                for (let channel: number = 0; channel < this.getChannelCount(); channel++) {
                    // Length of channel name string. Due to some crazy Unicode characters this needs to be 2 bytes...
                   let channelNameLength;
                   if (fromSomethingBox) {
                       // SomethingBox always writes a 2-byte length.
                       channelNameLength = ((base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                   } else if (beforeFour && !fromGoldBox && !fromUltraBox && !fromSlarmoosBox && !fromSomethingBox) {
                        channelNameLength = base64CharCodeToInt[compressed.charCodeAt(charIndex++)]
                   } else {
                        channelNameLength = ((base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                   }
                    this.channels[channel].name = decodeURIComponent(compressed.substring(charIndex, charIndex + channelNameLength));

                    charIndex += channelNameLength;
                }
                URLDebugger.log("U", "channelNames", startIndex, charIndex, this.channels.map(c => c.name));
            } break;
            case SongTagCode.algorithm: {
                const startIndex = charIndex;
                const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];
                if (instrument.type == InstrumentType.fm) {
                    instrument.algorithm = clamp(0, Config.algorithms.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                }
                else {
                    instrument.algorithm6Op = clamp(0, Config.algorithms6Op.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);
                    instrument.customAlgorithm.fromPreset(instrument.algorithm6Op);
                    if (compressed.charCodeAt(charIndex) == SongTagCode.chord) {
                        let carrierCountTemp = clamp(1, Config.operatorCount + 2 + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex + 1)]);
                        charIndex++
                        let tempModArray: number[][] = [];
                        if (compressed.charCodeAt(charIndex + 1) == SongTagCode.effects) {
                            charIndex++
                            let j: number = 0;
                            charIndex++
                            while (compressed.charCodeAt(charIndex) != SongTagCode.effects) {
                                tempModArray[j] = [];
                                let o: number = 0;
                                while (compressed.charCodeAt(charIndex) != SongTagCode.operatorWaves) {
                                    tempModArray[j][o] = clamp(1, Config.operatorCount + 3, base64CharCodeToInt[compressed.charCodeAt(charIndex)]);
                                    o++
                                    charIndex++
                                }
                                j++;
                                charIndex++
                            }
                            instrument.customAlgorithm.set(carrierCountTemp, tempModArray);
                            charIndex++; //????
                        }
                    }
                }
                if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox) || (beforeFour && fromGoldBox)) {
